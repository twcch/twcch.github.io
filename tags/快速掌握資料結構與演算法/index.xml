<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>快速掌握資料結構與演算法 on 志謙&#39;s Blog</title>
    <link>http://twcch.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 快速掌握資料結構與演算法 on 志謙&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 21 Sep 2025 00:00:00 +0800</lastBuildDate>
    <atom:link href="http://twcch.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>(Day 23) Bellman-Ford 演算法</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_23/</link>
      <pubDate>Sun, 21 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_23/</guid>
      <description>&lt;p&gt;在前一天我們介紹了 Dijkstra 演算法，它能有效解決 單源最短路徑 (Single Source Shortest Path, SSSP) 問題，但有一個限制: 不能處理負權重邊 (Negative Weights)。然而，現實世界的很多問題 (例如金融套利、債務網路、價格波動) 都可能出現負權重，這時候我們就需要 Bellman-Ford 演算法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;演算法背景&#34;&gt;演算法背景&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;發明者: Richard Bellman 與 Lester Ford (1958)&lt;/li&gt;&#xA;&lt;li&gt;適用場景&#xA;&lt;ul&gt;&#xA;&lt;li&gt;圖可能含有負權重邊&lt;/li&gt;&#xA;&lt;li&gt;需要檢測 負權重環 (Negative Weight Cycle)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;與 Dijkstra 的差異&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dijkstra 每次「貪心」取最短距離更新 → 高效，但不能處理負邊&lt;/li&gt;&#xA;&lt;li&gt;Bellman-Ford 採用「動態規劃」思想，不斷鬆弛邊，最終收斂到最短路徑&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;核心思想&lt;/p&gt;&#xA;&lt;p&gt;Bellman-Ford 的核心是 邊鬆弛 (Relaxation):&#xA;對於一條邊 $(u, v)$ 以及權重 $w(u, v)$，如果:&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;dist[v] &amp;gt; dist[u] + w(u, v)&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;則更新:&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;dist[v] = dist[u] + w(u, v)&#xA;$$&lt;/p&gt;&#xA;&lt;h2 id=&#34;演算法步驟&#34;&gt;演算法步驟&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;對所有節點距離 dist[v] = ∞&lt;/li&gt;&#xA;&lt;li&gt;起點 dist[start] = 0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;鬆弛操作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重複 V-1 次 (V 為節點數)&lt;/li&gt;&#xA;&lt;li&gt;每次遍歷所有邊，嘗試更新距離&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;檢測負權重環&#xA;&lt;ul&gt;&#xA;&lt;li&gt;再做一次鬆弛，如果還能更新，代表存在 負權重環&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;python-程式碼&#34;&gt;Python 程式碼&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bellman_ford&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;graph&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# graph: list of edges [(u, v, w), ...]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# V: 節點數量&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# Step 1: 鬆弛 V-1 次&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;graph&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;dist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;w&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# Step 2: 檢查是否有負權重環&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;graph&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;圖中存在負權重環&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dist&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 測試&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;edges&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bellman_ford&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;edges&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 輸出: [0, -1, 2, -2, 1]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;複雜度分析&#34;&gt;複雜度分析&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;時間複雜度: $O(V \times E)$&lt;/li&gt;&#xA;&lt;li&gt;V 為節點數，E 為邊數&lt;/li&gt;&#xA;&lt;li&gt;適合邊數不多 (Sparse Graph) 的圖&lt;/li&gt;&#xA;&lt;li&gt;空間複雜度: $O(V)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;與 Dijkstra 相比:&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 22) Dijkstra 最短路徑演算法 (Dijkstra’s Algorithm)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_22/</link>
      <pubDate>Sat, 20 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_22/</guid>
      <description>&lt;p&gt;Dijkstra 最短路徑演算法是一種用於計算從單一源點到圖中所有其他節點的最短路徑的經典演算法。這個演算法適用於加權圖，其中邊的權重必須是非負的，核心思想是每次選擇「距離起點最近」的尚未處理節點，並用它來更新鄰居的最短距離，這種策略屬於貪心演算法 (Greedy Algorithm)&lt;/p&gt;&#xA;&lt;h2 id=&#34;演算法步驟&#34;&gt;演算法步驟&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;將所有節點的距離設為無限大，除了起始節點，其距離設為 0&lt;/li&gt;&#xA;&lt;li&gt;將所有節點標記為未訪問&lt;/li&gt;&#xA;&lt;li&gt;使用一個優先佇列 (通常是最小堆) 來追蹤當前已知的最短距離&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;選擇節點&#xA;&lt;ul&gt;&#xA;&lt;li&gt;從優先佇列中選擇距離起始節點最近的未訪問節點，將其標記為訪問過&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;更新鄰居&#xA;&lt;ul&gt;&#xA;&lt;li&gt;對於該節點的每一個鄰居，計算從起始節點經過該節點到鄰居的距離&lt;/li&gt;&#xA;&lt;li&gt;如果這個距離小於目前記錄的距離，則更新鄰居的距離，並將其加入優先佇列&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;重複&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重複步驟 2 和 3，直到所有節點都被訪問過&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;結束&#xA;&lt;ul&gt;&#xA;&lt;li&gt;當所有節點都被訪問過後，從起始節點到其他所有節點的最短路徑距離即已計算完成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;&#xA;&lt;p&gt;假設有一個圖如下:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;A --(1)--&amp;gt; B&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;A --(4)--&amp;gt; C&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;B --(2)--&amp;gt; C&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;B --(5)--&amp;gt; D&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;C --(1)--&amp;gt; D&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;起始節點為 A&lt;/li&gt;&#xA;&lt;li&gt;初始化: A 的距離為 0，B、C、D 的距離為無限大&lt;/li&gt;&#xA;&lt;li&gt;從 A 開始，更新 B 和 C 的距離&lt;/li&gt;&#xA;&lt;li&gt;選擇距離最小的 B，更新 C 和 D 的距離&lt;/li&gt;&#xA;&lt;li&gt;選擇距離最小的 C，更新 D 的距離&lt;/li&gt;&#xA;&lt;li&gt;最後選擇 D，所有節點都被訪問過&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;複雜度&#34;&gt;複雜度&lt;/h2&gt;&#xA;&lt;p&gt;Dijkstra 演算法的時間複雜度取決於使用的資料結構。若使用二元堆，時間複雜度為 $O((V + E) \log V)$，其中 $V$ 是節點數，$E$ 是邊數&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 21) 圖演算法 (Graph Algorithm)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_21/</link>
      <pubDate>Fri, 19 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_21/</guid>
      <description>&lt;p&gt;自從我們 Day 10 簡單地說一下圖結構後，就再也沒提到這個詞，我們今天開始就要介紹這個應用非常廣泛的圖 (Graph) 的演算法總覽，後續會接著介紹常見的圖演算法，因為圖是非線性資料結構中最重要的一員，在學術研究與實務應用上都有極高地位，從網路連線、地圖導航、社交網路到金融交易，幾乎都離不開圖的建模與演算法&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本定義&#34;&gt;基本定義&lt;/h2&gt;&#xA;&lt;p&gt;一個圖 (Graph) 由 頂點 (Vertex) 與 邊 (Edge) 所組成。形式化表示為 $G = (V, E)$:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$V$ 是頂點集合&lt;/li&gt;&#xA;&lt;li&gt;$E$ 是邊的集合，每一條邊連接兩個頂點&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;圖可以依照性質分類:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有向圖 (Directed Graph) 與 無向圖 (Undirected Graph)&lt;/li&gt;&#xA;&lt;li&gt;加權圖 (Weighted Graph) 與 非加權圖 (Unweighted Graph)&lt;/li&gt;&#xA;&lt;li&gt;稠密圖 (Dense Graph) 與 稀疏圖 (Sparse Graph)&lt;/li&gt;&#xA;&lt;li&gt;循環圖 (Cyclic Graph) 與 非循環圖 (Acyclic Graph)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;圖的表示方法&#34;&gt;圖的表示方法&lt;/h2&gt;&#xA;&lt;p&gt;圖的常見儲存方式主要有兩種:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;鄰接矩陣 (Adjacency Matrix)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用一個 $n \times n$ 的矩陣來表示&lt;/li&gt;&#xA;&lt;li&gt;若頂點 $i$ 與 $j$ 之間有邊，則 $A[i][j] = 1$ (或權重值)&lt;/li&gt;&#xA;&lt;li&gt;適合稠密圖，但空間複雜度為 $O(n^2)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;鄰接串列 (Adjacency List)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;對於每個頂點，維護一個相鄰頂點的串列&lt;/li&gt;&#xA;&lt;li&gt;適合稀疏圖，空間複雜度接近 $O(V + E)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;圖的遍歷演算法&#34;&gt;圖的遍歷演算法&lt;/h2&gt;&#xA;&lt;p&gt;遍歷是理解圖結構的基礎，常見方法有:&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 20) 貪婪演算法 (Greedy Algorithm)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_20/</link>
      <pubDate>Thu, 18 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_20/</guid>
      <description>&lt;p&gt;貪婪演算法 (Greedy Algorithm) 是一種在每一步選擇中都採取在當前狀態下最好或最優 (即最有利) 的選擇，從而希望導致結果是全局最好或最優的演算法。這種方法每次做出選擇時，只考慮當前最優解，而不考慮未來的後果&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本思想&#34;&gt;基本思想&lt;/h2&gt;&#xA;&lt;p&gt;貪婪演算法的核心思想是: 每一步都做出在當前狀態下看起來最好的選擇，而不考慮未來的後果。這種方法並不總是能得到最優解，但對於某些特定問題，貪婪策略可以保證得到全局最優解&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本步驟&#34;&gt;基本步驟&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;選擇: 根據某種標準，從當前可行的選擇中選出最優者&lt;/li&gt;&#xA;&lt;li&gt;可行性檢查: 判斷這個選擇是否導致問題無法繼續求解&lt;/li&gt;&#xA;&lt;li&gt;合併: 將這個選擇加入到已選擇的集合中&lt;/li&gt;&#xA;&lt;li&gt;重複: 重複上述步驟，直到達到結束條件&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;經典範例&#34;&gt;經典範例&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;找零問題 (Coin Change Problem): 給定不同面額的硬幣，要求用最少的硬幣數湊出指定金額。對於某些硬幣組合，貪婪法能得到最優解&lt;/li&gt;&#xA;&lt;li&gt;活動選擇問題 (Activity Selection Problem): 選擇最多不重疊的活動，通常按照結束時間最早的活動優先選擇&lt;/li&gt;&#xA;&lt;li&gt;最小生成樹 (Minimum Spanning Tree): 如 Kruskal 和 Prim 演算法，都是貪婪策略的應用&lt;/li&gt;&#xA;&lt;li&gt;哈夫曼編碼 (Huffman Coding): 用於資料壓縮的哈夫曼樹構建過程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;優點&#34;&gt;優點&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;實現簡單，通常只需一個迴圈或遞迴&lt;/li&gt;&#xA;&lt;li&gt;執行效率高，時間複雜度低&lt;/li&gt;&#xA;&lt;li&gt;適合於可以證明貪婪選擇性質和最優子結構的問題&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;缺點&#34;&gt;缺點&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;並非所有問題都適用，對於某些問題可能無法得到最優解&lt;/li&gt;&#xA;&lt;li&gt;需要證明問題具有「貪婪選擇性質」和「最優子結構」&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;舉例說明&#34;&gt;舉例說明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;活動選擇問題&#34;&gt;活動選擇問題&lt;/h3&gt;&#xA;&lt;p&gt;假設有多個活動，每個活動有開始和結束時間，要求選擇最多不重疊的活動。貪婪策略是每次選擇結束時間最早且不與已選活動重疊的活動。&lt;/p&gt;&#xA;&lt;h3 id=&#34;找零問題&#34;&gt;找零問題&lt;/h3&gt;&#xA;&lt;p&gt;如果硬幣是 [1, 3, 4]，我要湊 6 元，使用貪婪 (每次拿最大硬幣) 會得到哪個組合?&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;先拿最大但不超過 6 的 → 4 → 剩下 2&lt;/li&gt;&#xA;&lt;li&gt;再拿最大 → 1 → 剩下 1&lt;/li&gt;&#xA;&lt;li&gt;再拿最大 → 1 → 剩下 0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;總共: 4 + 1 + 1 = 6，用了 3 枚硬幣&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 19) 動態規劃 (Dynamic Programming)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_19/</link>
      <pubDate>Wed, 17 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_19/</guid>
      <description>&lt;p&gt;動態規劃 (Dynamic Programming; DP) 是一種將複雜問題分解為較小子問題，並儲存子問題解以避免重複計算的演算法設計方法。它常用於具有「重疊子問題」和「最優子結構」性質的問題&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本思想&#34;&gt;基本思想&lt;/h2&gt;&#xA;&lt;p&gt;動態規劃的核心思想是: 將原問題拆解成多個子問題，先解決並記錄子問題的解，當需要時直接查詢，從而提升效率。這種方法通常用於遞迴解法會產生大量重複計算的情況&lt;/p&gt;&#xA;&lt;h2 id=&#34;適用條件&#34;&gt;適用條件&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重疊子問題 (Overlapping Subproblems): 題可以分解為重複出現的子問題&lt;/li&gt;&#xA;&lt;li&gt;最優子結構 (Optimal Substructure): 問題的最優解可以由子問題的最優解組合而成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;基本步驟&#34;&gt;基本步驟&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;定義狀態: 找出如何用一組變數描述子問題&lt;/li&gt;&#xA;&lt;li&gt;狀態轉移方程: 找出子問題之間的遞推關係 (即狀態如何由更小的狀態推導而來)&lt;/li&gt;&#xA;&lt;li&gt;初始化: 設定最基本的子問題解 (通常是最小規模的情況)&lt;/li&gt;&#xA;&lt;li&gt;計算順序: 決定計算子問題的順序，通常是自底向上 (迴圈) 或自頂向下 (遞迴+記憶化)&lt;/li&gt;&#xA;&lt;li&gt;輸出答案: 根據需求輸出最終解&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;經典範例&#34;&gt;經典範例&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;費波那契數列 (Fibonacci Sequence): $F(n) = F(n-1) + F(n-2)$，用陣列儲存已計算的值&lt;/li&gt;&#xA;&lt;li&gt;最短路徑問題 (Shortest Path): 如 Floyd-Warshall 演算法&lt;/li&gt;&#xA;&lt;li&gt;背包問題 (Knapsack Problem): 給定物品重量和價值，求在容量限制下的最大總價值&lt;/li&gt;&#xA;&lt;li&gt;最長公共子序列 (Longest Common Subsequence, LCS): 求兩個序列的最長公共子序列長度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;優點&#34;&gt;優點&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大幅減少重複計算，提高效率&lt;/li&gt;&#xA;&lt;li&gt;適合解決最優化問題&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;缺點&#34;&gt;缺點&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要額外的空間儲存子問題解&lt;/li&gt;&#xA;&lt;li&gt;狀態設計和轉移方程推導有時較困難&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;舉例說明&#34;&gt;舉例說明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;費波那契數列&#34;&gt;費波那契數列&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;無使用動態規劃 (單純 Divide and Conquer)&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 18) 分治法 (Divide and Conquer)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_18/</link>
      <pubDate>Tue, 16 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_18/</guid>
      <description>&lt;p&gt;前面介紹了幾個簡單又常見的排序與搜尋的演算法，接下來我們來談談演算法設計策略，仿間有很多演算法的書並不會特地把 Divide and Conquer 或 Dynamic Programming 編成一個章節，這也導致新手學完了一些演算法後，不知道自己學的是 Divide and Conquer 或 Dynamic Programming，這也包括我，所以我們在來花幾天的時間來談談這些演算法設計策略。&lt;/p&gt;&#xA;&lt;p&gt;分治法 (Divide and Conquer) 是一種常見演算法設計策略，廣泛應用於解決複雜問題。其核心思想是將一個大問題分解成若干個較小且結構相似的子問題，分別解決這些子問題後，再將它們的解合併，從而得到原問題的解。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本步驟&#34;&gt;基本步驟&lt;/h2&gt;&#xA;&lt;p&gt;分治法通常包含以下三個步驟:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;分解 (Divide): 將原問題分解成若干個規模較小、結構與原問題相同的子問題&lt;/li&gt;&#xA;&lt;li&gt;解決 (Conquer): 遞迴地解決這些子問題。如果子問題足夠小，則直接求解&lt;/li&gt;&#xA;&lt;li&gt;合併 (Combine): 將子問題的解合併成原問題的解&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;經典範例&#34;&gt;經典範例&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;合併排序 (Merge Sort): 將數列分成兩半，分別排序後再合併&lt;/li&gt;&#xA;&lt;li&gt;快速排序 (Quick Sort): 選擇一個基準值，將數列分為小於和大於基準值的兩部分，分別排序&lt;/li&gt;&#xA;&lt;li&gt;最大子陣列問題 (Maximum Subarray Problem): 將陣列分成兩半，遞迴求解，並合併結果&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;優點&#34;&gt;優點&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;能夠顯著降低某些問題的時間複雜度&lt;/li&gt;&#xA;&lt;li&gt;適合用於可以自然分割成子問題的問題&lt;/li&gt;&#xA;&lt;li&gt;易於實現遞迴&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;缺點&#34;&gt;缺點&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;遞迴過程可能導致較高的空間複雜度 (如遞迴棧)&lt;/li&gt;&#xA;&lt;li&gt;對於不能有效分割或合併的問題，分治法不適用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;時間複雜度分析&#34;&gt;時間複雜度分析&lt;/h2&gt;&#xA;&lt;p&gt;分治法的時間複雜度通常可以用遞迴式表示，例如合併排序的時間複雜度為: $T(n) = 2T\left(\frac{n}{2}\right) + O(n)$，利用主定理 (Master Theorem) 可以求得 $T(n) = O(n \log n)$&lt;/p&gt;&#xA;&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;&#xA;&lt;p&gt;分治法是一種高效且靈活的演算法設計方法，適合解決許多具有遞迴結構的問題。掌握分治法對於學習演算法和解決實際問題都非常有幫助。&lt;/p&gt;&#xA;&lt;h2 id=&#34;備註&#34;&gt;備註&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步發表於 &lt;a href=&#34;https://ithelp.ithome.com.tw/users/20163705/ironman/8468&#34;&gt;iThome 鐵人賽 2025 - 快速掌握資料結構與演算法&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>(Day 17) 內插搜尋 (Interpolation Search)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_17/</link>
      <pubDate>Mon, 15 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_17/</guid>
      <description>&lt;p&gt;內插搜尋 (Interpolation Search) 是一種基於數值分布估算落點的搜尋演算法，是對 二元搜尋 (Binary Search) 的改良。它特別適合用在已排序且元素分布相對均勻的資料集上，能有效地減少搜尋次數。&lt;/p&gt;&#xA;&lt;h2 id=&#34;為什麼要用內插搜尋&#34;&gt;為什麼要用內插搜尋?&lt;/h2&gt;&#xA;&lt;p&gt;二元搜尋每次都「取中間」，假設資料大致均勻地分佈，但若目標值靠近開頭，仍會浪費許多比較。&lt;/p&gt;&#xA;&lt;p&gt;舉例: 假設我們要找 3&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;資料是 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/li&gt;&#xA;&lt;li&gt;Binary Search 會先看中間 5，再往左看 2~4&lt;/li&gt;&#xA;&lt;li&gt;Interpolation Search 則會「預測」目標在偏左，第一次就可能落在 3 附近&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;核心概念: 根據數值的相對大小，估計出目標可能所在的位置。&lt;/p&gt;&#xA;&lt;h2 id=&#34;公式原理&#34;&gt;公式原理&lt;/h2&gt;&#xA;&lt;p&gt;在每次搜尋中，透過「線性內插公式」計算預估位置 pos:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pos = left + (target - arr[left]) * (right - left) // (arr[right] - arr[left])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;left / right: 目前搜尋區間邊界&lt;/li&gt;&#xA;&lt;li&gt;arr[left] / arr[right]: 邊界的值&lt;/li&gt;&#xA;&lt;li&gt;target: 要搜尋的值&lt;/li&gt;&#xA;&lt;li&gt;pos: 根據比例估算出的落點位置&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果 arr[left] == arr[right](例如所有元素相同)，為避免除以 0，應直接檢查元素是否等於 target。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 16) 二元搜尋 (Binary Search)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_16/</link>
      <pubDate>Sun, 14 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_16/</guid>
      <description>&lt;p&gt;在排序演算法之後，我們終於要介紹一個非常經典且實用的搜尋演算法 —— 二元搜尋 (Binary Search)。如果說排序演算法是「把資料整理好」，那麼搜尋演算法就是「如何在整理好的資料中快速找到想要的元素」。二元搜尋憑藉著「折半」的概念，將搜尋的時間複雜度大幅降低。&lt;/p&gt;&#xA;&lt;h2 id=&#34;演算法概念&#34;&gt;演算法概念&lt;/h2&gt;&#xA;&lt;p&gt;二元搜尋的基本思想是:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前提：資料必須是 有序的陣列 (升冪或降冪都可以，但必須一致)。&lt;/li&gt;&#xA;&lt;li&gt;方法：每次將搜尋範圍對半切割，並檢查中間元素。&lt;/li&gt;&#xA;&lt;li&gt;若中間元素剛好等於目標值 → 成功找到。&lt;/li&gt;&#xA;&lt;li&gt;若目標值小於中間元素 → 在左半邊繼續搜尋。&lt;/li&gt;&#xA;&lt;li&gt;若目標值大於中間元素 → 在右半邊繼續搜尋。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;透過「每次將搜尋範圍減半」，演算法的效率大幅提升。&lt;/p&gt;&#xA;&lt;h2 id=&#34;演算法步驟&#34;&gt;演算法步驟&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;設定左邊界 left = 0，右邊界 right = n - 1。&lt;/li&gt;&#xA;&lt;li&gt;當 left &amp;lt;= right 時，計算中間索引 mid = (left + right) // 2。&lt;/li&gt;&#xA;&lt;li&gt;如果 arr[mid] == target，回傳 mid。&lt;/li&gt;&#xA;&lt;li&gt;如果 arr[mid] &amp;gt; target，將右邊界移到 mid - 1。&lt;/li&gt;&#xA;&lt;li&gt;如果 arr[mid] &amp;lt; target，將左邊界移到 mid + 1。&lt;/li&gt;&#xA;&lt;li&gt;若最終沒有找到，回傳 -1（表示不存在）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;程式碼範例&#34;&gt;程式碼範例&lt;/h2&gt;&#xA;&lt;h3 id=&#34;iterative-版本&#34;&gt;Iterative 版本&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;binary_search&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;elif&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 測試&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;binary_search&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;# 輸出: 3&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;binary_search&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;# 輸出: -1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;recursive-版本&#34;&gt;Recursive 版本&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;binary_search_recursive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;elif&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;binary_search_recursive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;binary_search_recursive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 測試&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;binary_search_recursive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;# 輸出: 3&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;binary_search_recursive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;# 輸出: -1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;複雜度分析&#34;&gt;複雜度分析&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;時間複雜度: 每次搜尋範圍縮小一半，最多重複 log2(n) 次。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最佳情況: $O(1)$ (剛好中間值就是目標)。&lt;/li&gt;&#xA;&lt;li&gt;最壞情況: $O(\log n)$。&lt;/li&gt;&#xA;&lt;li&gt;平均情況: $O(\log n)$。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;空間複雜度&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Iterative 版本: $O(1)$。&lt;/li&gt;&#xA;&lt;li&gt;Recursive 版本: 因遞迴棧的存在，$O(\log n)$。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;優缺點&#34;&gt;優缺點&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;優點&lt;/th&gt;&#xA;          &lt;th&gt;缺點&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;時間效率高，$O(\log n)$&lt;/td&gt;&#xA;          &lt;td&gt;限制多: 必須是有序陣列&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;實作簡單&lt;/td&gt;&#xA;          &lt;td&gt;適合靜態資料，不適合頻繁插入刪除的場景&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;遞迴/迴圈皆可實作&lt;/td&gt;&#xA;          &lt;td&gt;若資料不排序，必須先排序，否則無法使用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;&#xA;&lt;p&gt;二元搜尋是一個簡單卻威力強大的演算法，它清楚展現了「減少搜尋範圍」能帶來的效率提升。雖然它只適用於有序資料，但在演算法設計中，「化問題為二分判斷」是一個常見且強大的思維模式。理解二元搜尋後，往後你在刷演算法題時會發現，許多問題都能用「Binary Search on Answer」這個技巧來解。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 15) 基礎排序演算法比較</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_15/</link>
      <pubDate>Sat, 13 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_15/</guid>
      <description>&lt;p&gt;在前面三天，我們分別介紹了氣泡排序 (Bubble Sort)、選擇排序 (Selection Sort)、插入排序 (Insertion Sort)。這三個演算法都是經典的「基礎排序」，時間複雜度同樣是 $O(n^2)$，但它們在設計思路、操作方式、適用場景上各有不同。今天我們就來做一次系統化的分析比較。&lt;/p&gt;&#xA;&lt;h2 id=&#34;設計思路&#34;&gt;設計思路&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;氣泡排序 (Bubble Sort): 核心概念是「交換相鄰元素」，每一輪把最大（或最小）的元素一步步冒泡到邊界。&lt;/li&gt;&#xA;&lt;li&gt;選擇排序 (Selection Sort): 核心概念是「每輪選出極值」，然後與前端位置交換。&lt;/li&gt;&#xA;&lt;li&gt;插入排序 (Insertion Sort): 核心概念是「維持已排序區」，每次將新元素插入到正確位置。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可以看到，三者的直覺都很容易理解:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;氣泡像是把氣泡推到最上面。&lt;/li&gt;&#xA;&lt;li&gt;選擇像是比賽排名，每次挑出最小值。&lt;/li&gt;&#xA;&lt;li&gt;插入像是整理撲克牌，每張牌插到正確位置。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;演算法流程比較&#34;&gt;演算法流程比較&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;演算法&lt;/th&gt;&#xA;          &lt;th&gt;核心操作&lt;/th&gt;&#xA;          &lt;th&gt;一輪結束的效果&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;氣泡排序&lt;/td&gt;&#xA;          &lt;td&gt;交換相鄰元素&lt;/td&gt;&#xA;          &lt;td&gt;把最大元素移到最後&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;選擇排序&lt;/td&gt;&#xA;          &lt;td&gt;找最小值並交換&lt;/td&gt;&#xA;          &lt;td&gt;把最小元素移到最前&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;插入排序&lt;/td&gt;&#xA;          &lt;td&gt;插入到有序區&lt;/td&gt;&#xA;          &lt;td&gt;維持前半段總是有序&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;複雜度分析&#34;&gt;複雜度分析&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;演算法&lt;/th&gt;&#xA;          &lt;th&gt;最佳情況&lt;/th&gt;&#xA;          &lt;th&gt;平均情況&lt;/th&gt;&#xA;          &lt;th&gt;最壞情況&lt;/th&gt;&#xA;          &lt;th&gt;空間複雜度&lt;/th&gt;&#xA;          &lt;th&gt;穩定性&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;氣泡排序&lt;/td&gt;&#xA;          &lt;td&gt;$O(n)$ (若加早停機制)&lt;/td&gt;&#xA;          &lt;td&gt;$O(n^2)$&lt;/td&gt;&#xA;          &lt;td&gt;$O(n^2)$&lt;/td&gt;&#xA;          &lt;td&gt;$O(1)$&lt;/td&gt;&#xA;          &lt;td&gt;穩定&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;選擇排序&lt;/td&gt;&#xA;          &lt;td&gt;$O(n^2)$&lt;/td&gt;&#xA;          &lt;td&gt;$O(n^2)$&lt;/td&gt;&#xA;          &lt;td&gt;$O(n^2)$&lt;/td&gt;&#xA;          &lt;td&gt;$O(1)$&lt;/td&gt;&#xA;          &lt;td&gt;不穩定&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;插入排序&lt;/td&gt;&#xA;          &lt;td&gt;$O(n)$ (幾乎有序時)&lt;/td&gt;&#xA;          &lt;td&gt;$O(n^2)$&lt;/td&gt;&#xA;          &lt;td&gt;$O(n^2)$&lt;/td&gt;&#xA;          &lt;td&gt;$O(1)$&lt;/td&gt;&#xA;          &lt;td&gt;穩定&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;優缺點比較&#34;&gt;優缺點比較&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;演算法&lt;/th&gt;&#xA;          &lt;th&gt;優點&lt;/th&gt;&#xA;          &lt;th&gt;缺點&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;氣泡排序&lt;/td&gt;&#xA;          &lt;td&gt;概念直觀，易於實作；加上早停機制時，已排序資料效率高&lt;/td&gt;&#xA;          &lt;td&gt;大量交換，實務效率低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;選擇排序&lt;/td&gt;&#xA;          &lt;td&gt;每輪最多一次交換，交換次數少；程式簡單&lt;/td&gt;&#xA;          &lt;td&gt;不穩定；最佳情況仍然是 $O(n^2)$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;插入排序&lt;/td&gt;&#xA;          &lt;td&gt;最佳情況 $O(n)$，適合小資料集或幾乎有序的資料；穩定&lt;/td&gt;&#xA;          &lt;td&gt;平均/最壞仍是 $O(n^2)$，不適合大規模資料&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;適用場景&#34;&gt;適用場景&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;氣泡排序: 適合教學與理解「交換」的概念，不適合實務使用。&lt;/li&gt;&#xA;&lt;li&gt;選擇排序: 在「交換成本高」但「比較成本低」的場景可能有用，但實務上幾乎被淘汰。&lt;/li&gt;&#xA;&lt;li&gt;插入排序:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;適合小型資料集 (例如幾十筆以內)。&lt;/li&gt;&#xA;&lt;li&gt;適合幾乎有序的資料。&lt;/li&gt;&#xA;&lt;li&gt;常用於複雜排序演算法 (如 QuickSort、Timsort) 的子程序，提升效率。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;總結&#34;&gt;總結&lt;/h2&gt;&#xA;&lt;p&gt;氣泡、選擇、插入三種排序演算法雖然都屬於 $O(n^2)$，但它們代表了三種不同的思路:&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 14) 插入排序 (Insertion Sort)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_14/</link>
      <pubDate>Fri, 12 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_14/</guid>
      <description>&lt;p&gt;插入排序 (Insertion Sort) 也是一種簡單直觀的排序演算法。它的工作原理是通過構建有序序列，對於未排序資料，在已排序序列中從後向前掃描，找到相應位置並插入。&lt;/p&gt;&#xA;&lt;h2 id=&#34;演算法步驟&#34;&gt;演算法步驟&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;從第二個元素開始，將該元素與前面的元素進行比較。&lt;/li&gt;&#xA;&lt;li&gt;如果該元素比前面的元素小，則將前面的元素往後移動一位。&lt;/li&gt;&#xA;&lt;li&gt;重複步驟2，直到找到該元素應插入的位置。&lt;/li&gt;&#xA;&lt;li&gt;將該元素插入到正確的位置。&lt;/li&gt;&#xA;&lt;li&gt;重複步驟1~4，直到所有元素都排序完成。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;範例&#34;&gt;範例&lt;/h2&gt;&#xA;&lt;p&gt;假設有一個陣列 $A = [5, 2, 4, 6, 1, 3]$，插入排序的過程如下:&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;步驟&lt;/th&gt;&#xA;          &lt;th&gt;陣列狀態&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;初始&lt;/td&gt;&#xA;          &lt;td&gt;5, 2, 4, 6, 1, 3&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;2, 5, 4, 6, 1, 3&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;2, 4, 5, 6, 1, 3&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3&lt;/td&gt;&#xA;          &lt;td&gt;2, 4, 5, 6, 1, 3&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;1, 2, 4, 5, 6, 3&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;5&lt;/td&gt;&#xA;          &lt;td&gt;1, 2, 3, 4, 5, 6&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;程式碼範例&#34;&gt;程式碼範例&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;insertion_sort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 測試&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insertion_sort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;複雜度分析&#34;&gt;複雜度分析&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最佳情況：$O(n)$（已排序）&lt;/li&gt;&#xA;&lt;li&gt;最壞情況：$O(n^2)$（反向排序）&lt;/li&gt;&#xA;&lt;li&gt;穩定性：穩定排序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;優缺點&#34;&gt;優缺點&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;優點&lt;/th&gt;&#xA;          &lt;th&gt;缺點&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;實作簡單&lt;/td&gt;&#xA;          &lt;td&gt;效率較低，適合小型資料集&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;穩定排序&lt;/td&gt;&#xA;          &lt;td&gt;不適合大型資料集&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;&#xA;&lt;p&gt;插入排序雖然與氣泡排序、選擇排序一樣屬於 O(n^2) 的基礎排序演算法，但它的特性更貼近「人類整理資料」的直覺思維：就像整理撲克牌一樣，每次抽一張牌，插入到已經排好的手牌中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 13) 選擇排序 (Selection Sort)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_13/</link>
      <pubDate>Thu, 11 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_13/</guid>
      <description>&lt;p&gt;選擇排序 (Selection Sort) 是一種簡單直觀的排序演算法。核心概念: 每一輪從尚未排序的元素中挑出最小 (或最大) 者，放到目前應在的位置，一直重複直到完成。可以把它想成「選拔賽」: 第一輪選出最優放第一名，第二輪從剩下的人選次優放第二名，依此類推。&lt;/p&gt;&#xA;&lt;h2 id=&#34;演算法步驟&#34;&gt;演算法步驟&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;從索引 i = 0 開始，掃描區間 [i..n-1] 找到最小值的索引 min_idx，把 arr[i] 與 arr[min_idx] 交換。&lt;/li&gt;&#xA;&lt;li&gt;將 i 前進一格，重複步驟 1，直到 i = n-1 為止。&lt;/li&gt;&#xA;&lt;li&gt;全部就緒時，陣列即為遞增序。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;由於每一輪至少能確定一個元素的最終位置，總共需要執行 n-1 輪。&lt;/p&gt;&#xA;&lt;h2 id=&#34;範例說明&#34;&gt;範例說明&lt;/h2&gt;&#xA;&lt;p&gt;以序列 [29, 10, 14, 37, 13] 為例:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全陣列最小值是 10，與開頭 29 交換 → [10, 29, 14, 37, 13]&lt;/li&gt;&#xA;&lt;li&gt;在剩餘 [29, 14, 37, 13] 中最小是 13，與 29 交換 → [10, 13, 14, 37, 29]&lt;/li&gt;&#xA;&lt;li&gt;在剩餘 [14, 37, 29] 中最小是 14，位置不變 → [10, 13, 14, 37, 29]&lt;/li&gt;&#xA;&lt;li&gt;在剩餘 [37, 29] 中最小是 29，與 37 交換 → [10, 13, 14, 29, 37]&lt;/li&gt;&#xA;&lt;li&gt;完成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;程式碼範例&#34;&gt;程式碼範例&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;selection_sort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;min_idx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;min_idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;min_idx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;min_idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;min_idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;29&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;37&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;selection_sort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 輸出: [10, 13, 14, 29, 37]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;複雜度分析&#34;&gt;複雜度分析&lt;/h2&gt;&#xA;&lt;h3 id=&#34;時間複雜度&#34;&gt;時間複雜度&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最佳情況: O(n^2)&lt;/li&gt;&#xA;&lt;li&gt;最壞情況: O(n^2)&lt;/li&gt;&#xA;&lt;li&gt;平均情況: O(n^2)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;說明：即使資料本來已排序，外圈第 i 輪仍需在 [i..n-1] 全掃描以確認最小值，無法提前終止。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 12) 氣泡排序 (Bubble Sort)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_12/</link>
      <pubDate>Wed, 10 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_12/</guid>
      <description>&lt;p&gt;終於進入演算法的部分，預計會介紹 3~4 個很常見的排序演算法，所以光排序這個主題就會用掉一些篇幅，今天除了介紹 Bubble Sort 外，會先簡單介紹一下排序，讓各位讀者更好地認識排序演算法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;排序概述&#34;&gt;排序概述&lt;/h2&gt;&#xA;&lt;p&gt;排序 (Sorting) 是演算法中最基礎且重要的主題之一，目的是將一組資料依照特定順序 (通常是從小到大或從大到小) 排列。而排序的過程中，資料的移動方式，資料的移動方式可以分為直接移動與邏輯移動:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;直接移動: 直接交換儲存資料的位置。&lt;/li&gt;&#xA;&lt;li&gt;邏輯移動: 不會移動資料儲存位置，僅改變資料的指標值。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;而排序又可以依照使用的記憶體種類區分:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;內部排序: 排序的資料量小，可以直接在記憶體內完成。&lt;/li&gt;&#xA;&lt;li&gt;外部排序: 排序的資料量大，無法直接在記憶體內完成，而必須使用到輔助記憶體 (e.g. 硬碟)。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;針對內部/外部排序常見的演算法如下:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;內部排序: 氣泡排序、選擇排序、插入排序、合併排序 &amp;hellip; 等。&lt;/li&gt;&#xA;&lt;li&gt;外部排序: 直接合併排序、k 路合併排序 &amp;hellip; 等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;氣泡排序&#34;&gt;氣泡排序&lt;/h2&gt;&#xA;&lt;p&gt;氣泡排序又稱交換排序法，原理如下:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;從第一個元素開始，比較相鄰元素大小，若大小順序有誤，則對調後再進行下一個元素比較。&lt;/li&gt;&#xA;&lt;li&gt;經過一次掃描後，可以確保最後一個元素是位於正確的順序。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;假設題目: 使用氣泡排序法將數列 [16, 25, 39, 27, 12, 8, 45, 63] 排序，直接操作一次:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;39&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;27&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;45&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;63&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這個程式很簡單就是不斷地交換而已，其實上面的是標準版版本的 Bubble Sort，我以前不知道為什麼很容易忘記，我個人比較喜歡下面這個版本:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;39&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;27&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;45&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;63&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這個版本是我自己改的，因為我個人在解演算法題目，都一律先用雙指針想想看能不能解，雖然這個版本符合 Bubble Sort 的核心概念，而且兩個版本的時間複雜度跟空間複雜度都一樣，但是並不是標準版本，所以在考試的時候最好還是寫標準版，不然可能會被算錯。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 11) 演算法評估 (Algorithm Analysis)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_11/</link>
      <pubDate>Tue, 09 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_11/</guid>
      <description>&lt;p&gt;到目前為止，我們已經介紹了各種資料結構 (Array、Linked List、Stack、Queue、Tree、Graph)，也練習了基本操作。但光有資料結構還不夠，要能設計演算法，就必須懂得如何評估一個演算法的效率。&lt;/p&gt;&#xA;&lt;p&gt;這篇我們要正式進入演算法分析 (Algorithm Analysis)，也就是回答以下問題:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;這個演算法在不同輸入規模下，執行需要多少時間?&lt;/li&gt;&#xA;&lt;li&gt;這個演算法需要多少額外的記憶體?&lt;/li&gt;&#xA;&lt;li&gt;在實務上，它和其他解法相比誰更好?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;為什麼要分析演算法&#34;&gt;為什麼要分析演算法?&lt;/h2&gt;&#xA;&lt;p&gt;在軟體工程或面試中，我們常聽到: 「時間複雜度是多少?」、「能不能把 $O(n^2)$ 降到 $O(n \log n)$?」這些問題的本質就是演算法效率。&lt;/p&gt;&#xA;&lt;p&gt;舉例:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;排序一百萬筆資料，$O(n^2)$ 的冒泡排序會慢得無法接受，而 $O(n \log n)$ 的快速排序可以在合理時間內完成。&lt;/li&gt;&#xA;&lt;li&gt;查詢資料時，用 Array 遍歷 ($O(n)$) 與用 Hash Table 查找 ($O(1)$ 平均) 的差異，會直接影響效能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所以，演算法分析的目的不是「找最炫的解法」，而是在輸入規模變大時，哪個演算法更可擴展 (scalable)。&lt;/p&gt;&#xA;&lt;h2 id=&#34;時間複雜度-time-complexity&#34;&gt;時間複雜度 (Time Complexity)&lt;/h2&gt;&#xA;&lt;p&gt;時間複雜度衡量的是: 隨著輸入規模 $n$ 增加，演算法所需步驟數量的增長率。  這裡不考慮硬體速度、編譯器優化，而是純粹從數學角度來看，常用的表示法是 Big-O 表示法:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$O(1)$: 常數時間，輸入大小不影響效率。&lt;/li&gt;&#xA;&lt;li&gt;$O(\log n)$: 對數時間，每次將問題縮小一半，例如二分搜尋。&lt;/li&gt;&#xA;&lt;li&gt;$O(n)$: 線性時間，遍歷所有元素，例如尋找最大值。&lt;/li&gt;&#xA;&lt;li&gt;$O(n \log n)$: 接近線性的複雜度，例如快速排序、合併排序。&lt;/li&gt;&#xA;&lt;li&gt;$O(n^2)$: 平方時間，例如雙層迴圈。&lt;/li&gt;&#xA;&lt;li&gt;$O(2^n)$: 指數時間，例如遞迴解 NP 問題。&lt;/li&gt;&#xA;&lt;li&gt;$O(n!)$: 階乘時間，例如旅行推銷員的暴力解法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;常見範例&#34;&gt;常見範例&lt;/h2&gt;&#xA;&lt;h3 id=&#34;o1--常數時間&#34;&gt;$O(1)$ – 常數時間&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_first_element&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;無論陣列多大，只取第一個元素，時間固定。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 10) 圖 (Graph)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_10/</link>
      <pubDate>Mon, 08 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_10/</guid>
      <description>&lt;p&gt;這是資料結構的最後一篇，明天開始進入本系列的重點驗算法，前面幾天，我們介紹了各種樹結構 Binary Tree、Balanced Tree，以及其他衍生樹。而樹是一種特殊的圖結構，今天我們正式進入 Graph 的世界。&lt;/p&gt;&#xA;&lt;p&gt;圖是比樹更一般化的資料結構，能表示任何實體之間的關係，例如:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;社群網路 (人與人之間的連結)&lt;/li&gt;&#xA;&lt;li&gt;地圖 (城市與道路)&lt;/li&gt;&#xA;&lt;li&gt;網頁 (網頁與超連結)&lt;/li&gt;&#xA;&lt;li&gt;電腦網路 (節點與連線)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;理解圖結構，幾乎等於打開了資料結構與演算法的第二扇大門。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本定義&#34;&gt;基本定義&lt;/h2&gt;&#xA;&lt;p&gt;圖 (Graph) 由以下兩個元素組成:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;V (Vertices): 頂點 (節點, nodes)&lt;/li&gt;&#xA;&lt;li&gt;E (Edges): 邊 (連線, edges)，用來表示兩個頂點之間的關係&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;數學上通常記為:&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;G = (V, E)&#xA;$$&lt;/p&gt;&#xA;&lt;h2 id=&#34;圖的分類&#34;&gt;圖的分類&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有向圖 (Directed Graph) vs 無向圖 (Undirected Graph)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有向圖的邊有方向，例如 Twitter 的「追蹤關係」。&lt;/li&gt;&#xA;&lt;li&gt;無向圖的邊無方向，例如 Facebook 的「好友關係」。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;加權圖 (Weighted Graph) vs 無權圖 (Unweighted Graph)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;加權圖的邊帶有權重 (weight)，例如道路距離或網路傳輸延遲。&lt;/li&gt;&#xA;&lt;li&gt;無權圖則所有邊的權重相同。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;稠密圖 (Dense Graph) vs 稀疏圖 (Sparse Graph)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若邊的數量接近 $|V|^2$，稱為稠密圖。&lt;/li&gt;&#xA;&lt;li&gt;若邊的數量遠小於 $|V|^2$，稱為稀疏圖。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;循環圖 (Cyclic Graph) vs 非循環圖 (Acyclic Graph)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有迴路的圖稱為循環圖。&lt;/li&gt;&#xA;&lt;li&gt;無迴路的圖則是非循環圖 (例如樹)。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;圖的表示方式&#34;&gt;圖的表示方式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;鄰接矩陣-adjacency-matrix&#34;&gt;鄰接矩陣 (Adjacency Matrix)&lt;/h3&gt;&#xA;&lt;p&gt;使用二維陣列 $A[i][j]$ 表示是否存在一條從節點 i 到節點 j 的邊。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 9) 其他樹 (Other Trees)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_9/</link>
      <pubDate>Sun, 07 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_9/</guid>
      <description>&lt;p&gt;在前面兩天，粗淺的介紹了 Binary Tree 與 Balanced Tree，今天更粗淺的介紹一下其他樹，因為本系列只是要做一個拋磚引玉的動作，如果讀者對於資料結構有興趣，建議可以買書來研讀。&lt;/p&gt;&#xA;&lt;p&gt;樹的資料結構他的應用場景非常廣，比如機器學習的決策樹、極限梯度提升樹，或者是資料庫、檔案系統等應用場景，所以樹的資料結構不是僅僅的理論而已，讀者也許會疑惑說，為什麼好像介紹到樹就沒什麼程式碼，向機器學習的決策樹，它是一種機器學習的演算法，它使用的樹的資料結構去設計，所以光這個演算法要講清楚，就會花很久，也不是本系列的範圍，如果要深入的學樹模型，需要讀者自行找資源學習。&lt;/p&gt;&#xA;&lt;h2 id=&#34;各種樹&#34;&gt;各種樹&lt;/h2&gt;&#xA;&lt;p&gt;接下來，淺淺的介紹一下其他樹還有什麼&lt;/p&gt;&#xA;&lt;h3 id=&#34;b-tree&#34;&gt;B-Tree&lt;/h3&gt;&#xA;&lt;p&gt;B-Tree 是一種多路搜尋樹 (multi-way search tree)，與二元搜尋樹不同的是，它的每個節點可以擁有多於兩個子節點。&lt;/p&gt;&#xA;&lt;p&gt;特點:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;節點可以存放多個 key。&lt;/li&gt;&#xA;&lt;li&gt;每個節點的子樹數量 = key 數量 + 1。&lt;/li&gt;&#xA;&lt;li&gt;適合用在「磁碟存取」的場景，因為可以減少磁碟 I/O 次數。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;B-Tree 是資料庫索引的基礎，例如 MySQL 就使用 B-Tree 來實作索引。&lt;/p&gt;&#xA;&lt;h3 id=&#34;b-tree-1&#34;&gt;B+ Tree&lt;/h3&gt;&#xA;&lt;p&gt;B+ Tree 是 B-Tree 的延伸，改進點在於:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有資料都存放在葉節點，非葉節點只用來導航。&lt;/li&gt;&#xA;&lt;li&gt;葉節點之間使用 &lt;strong&gt;鏈結串列&lt;/strong&gt; 串接，支援範圍查詢。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;這讓 B+ Tree 在查詢時更有效率，特別是需要「區間搜尋」的情境。&lt;/p&gt;&#xA;&lt;h3 id=&#34;紅黑樹-red-black-tree&#34;&gt;紅黑樹 (Red-Black Tree)&lt;/h3&gt;&#xA;&lt;p&gt;紅黑樹是一種自平衡二元搜尋樹 (self-balancing BST)**，常用於準程式庫的實作，例如:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java 的 &lt;code&gt;TreeMap&lt;/code&gt;、&lt;code&gt;TreeSet&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;紅黑樹的規則:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;節點要嘛是紅色，要嘛是黑色。&lt;/li&gt;&#xA;&lt;li&gt;根節點一定是黑色。&lt;/li&gt;&#xA;&lt;li&gt;紅節點的子節點必須是黑色 (不能連續兩個紅色)。&lt;/li&gt;&#xA;&lt;li&gt;從根到每個葉節點的路徑，黑色節點數必須相同。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;這些限制保證了樹的高度維持在 $O(\log n)$，因此搜尋、插入、刪除都能保證在 $O(\log n)$ 完成。&lt;/p&gt;&#xA;&lt;h3 id=&#34;trie-樹-prefix-tree&#34;&gt;Trie 樹 (Prefix Tree)&lt;/h3&gt;&#xA;&lt;p&gt;Trie，又叫字典樹，專門用來處理字串集合的問題。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 8) 平衡樹 (Balanced Tree)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_8/</link>
      <pubDate>Sat, 06 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_8/</guid>
      <description>&lt;p&gt;Balanced Tree 是一種特殊的二元樹結構，旨在保持樹的高度盡可能低，以提高操作效率。常見的平衡樹包括 AVL 樹、紅黑樹和 B 樹等。以下是關於平衡樹的詳細介紹。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;二元樹: 是一種樹形數據結構，其中每個節點最多有兩個子節點，分別稱為左子節點和右子節點。&lt;/li&gt;&#xA;&lt;li&gt;平衡樹: 是一種二元樹，其特點是任何節點的兩個子樹的高度差不超過一個常數 (通常是 1)。這樣的結構確保了樹的高度保持在 $O(\log n)$，從而使得查找、插入和刪除操作的時間複雜度都能保持在 $O(\log n)$。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;平衡樹類型&#34;&gt;平衡樹類型&lt;/h2&gt;&#xA;&lt;h3 id=&#34;avl-樹&#34;&gt;AVL 樹&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定義: AVL樹是一種自平衡二元搜索樹，任何節點的兩個子樹的高度差不超過1。&lt;/li&gt;&#xA;&lt;li&gt;操作:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;插入: 插入後可能會破壞平衡，需要通過旋轉來恢復。&lt;/li&gt;&#xA;&lt;li&gt;刪除: 刪除後也可能需要旋轉來保持平衡。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;紅黑樹&#34;&gt;紅黑樹&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定義: 紅黑樹是一種自平衡二元搜索樹，每個節點都有一個顏色 (紅或黑)，並遵循以下規則:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;節點是紅色或黑色。&lt;/li&gt;&#xA;&lt;li&gt;根節點是黑色。&lt;/li&gt;&#xA;&lt;li&gt;每個葉子節點 (NIL 或空節點) 是黑色。&lt;/li&gt;&#xA;&lt;li&gt;如果一個節點是紅色，則其兩個子節點都是黑色。&lt;/li&gt;&#xA;&lt;li&gt;從任何節點到其每個葉子節點的所有路徑都包含相同數量的黑色節點。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;操作:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;插入: 插入後可能需要重新著色和旋轉來保持平衡。&lt;/li&gt;&#xA;&lt;li&gt;刪除: 刪除後也可能需要重新著色和旋轉。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;b-樹&#34;&gt;B 樹&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定義: B 樹是一種自平衡樹數據結構，適合用於存儲系統中需要大量讀寫操作的情況。B 樹的每個節點可以有多個子節點。&lt;/li&gt;&#xA;&lt;li&gt;特點:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;節點可以包含多個鍵和子節點。&lt;/li&gt;&#xA;&lt;li&gt;所有葉子節點位於同一層。&lt;/li&gt;&#xA;&lt;li&gt;B 樹的高度較低，適合磁盤存取。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;應用&#34;&gt;應用&lt;/h2&gt;&#xA;&lt;p&gt;平衡樹廣泛應用於需要快速查找、插入和刪除操作的場景，如數據庫索引、文件系統和內存管理等。&lt;/p&gt;&#xA;&lt;h2 id=&#34;優缺點&#34;&gt;優缺點&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;優點&#xA;&lt;ul&gt;&#xA;&lt;li&gt;高效的查找、插入和刪除操作。&lt;/li&gt;&#xA;&lt;li&gt;保持樹的高度低，從而提高操作效率。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;缺點&#xA;&lt;ul&gt;&#xA;&lt;li&gt;實現較為複雜。&lt;/li&gt;&#xA;&lt;li&gt;需要額外的旋轉和重新著色操作來保持平衡。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;&#xA;&lt;p&gt;平衡樹是一種強大的數據結構，能夠在多種應用中提供高效的操作性能。理解不同類型的平衡樹及其操作原理，對於設計高效的算法和系統至關重要。&lt;/p&gt;&#xA;&lt;h2 id=&#34;備註&#34;&gt;備註&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步發表於 &lt;a href=&#34;https://ithelp.ithome.com.tw/users/20163705/ironman/8468&#34;&gt;iThome 鐵人賽 2025 - 快速掌握資料結構與演算法&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>(Day 7) 二元樹 (Binary Tree)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_7/</link>
      <pubDate>Fri, 05 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_7/</guid>
      <description>&lt;p&gt;前面幾天所介紹的資料結構就是線性的資料結構，今天開始所介紹的樹資料節構是屬於非線性資料結構，也非常的重要。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本定義&#34;&gt;基本定義&lt;/h2&gt;&#xA;&lt;p&gt;在進入 Binary Tree 之前，先來介紹一下基本的組成部分，可以搭配著下圖看:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Root: 樹的起始點 (e.g. 2)&lt;/li&gt;&#xA;&lt;li&gt;Internal: 有子節點的節點 (e.g. 7, 5, 6, 9)&lt;/li&gt;&#xA;&lt;li&gt;Leaf: 沒有子節點的節點 (e.g. 2, 5, 11, 4)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/twcch/drive/raw/main/images/Image_2025-09-04_16-42-59.png&#34; alt=&#34;Image_2025-09-04_16-42-59.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Binary Tree 就是一個由有限節點所組成的集合，或由一個 Root 及左右兩個子樹所組成。簡單來說，Binary Tree 最多只能有兩個子節點 (也可以是一個)，Binary Tree 還可以再細分:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Fully Binary Tree&lt;/li&gt;&#xA;&lt;li&gt;Complete Binary Tree&lt;/li&gt;&#xA;&lt;li&gt;Skewed Binary Tree&lt;/li&gt;&#xA;&lt;li&gt;Strictly Binary Tree&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;這邊就先點到為止，不一一的詳細介紹。&lt;/p&gt;&#xA;&lt;h2 id=&#34;資料儲存方式&#34;&gt;資料儲存方式&lt;/h2&gt;&#xA;&lt;p&gt;Binary Tree 有很多種的儲存方式，比較常見的會是 Array 與 Linked List 的儲存方式，本篇就會分別介紹這兩種儲存方式。&lt;/p&gt;&#xA;&lt;h3 id=&#34;array-表示法&#34;&gt;Array 表示法&lt;/h3&gt;&#xA;&lt;p&gt;就直接用上一張圖的部分來說明，先對照一下，由上至下、由左至右的放入 Array。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A[1] = 2&lt;/li&gt;&#xA;&lt;li&gt;A[2] = 7, A[3] = 5&lt;/li&gt;&#xA;&lt;li&gt;A[4] = 2, A[5] = 6, A[6] = null, A[7] = 9&lt;/li&gt;&#xA;&lt;li&gt;A[8] = null, A[9] = null, A[10] = 5, A[11] = 11, A[12] = 4, A[13] = null&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/twcch/drive/raw/main/images/Image_2025-09-04_16-42-59.png&#34; alt=&#34;Image_2025-09-04_16-42-59.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 6) 隊列 (Queue)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_6/</link>
      <pubDate>Thu, 04 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_6/</guid>
      <description>&lt;p&gt;Queue (佇列) 與 Stack 一樣，是一種線性資料結構，但它遵循的是先進先出 (First-In-First-Out; FIFO) 的規則。你可以把 Queue 想像成排隊買票: 最早排隊的人會最先買到票並離開，而新加入的人只能站在隊伍最後。&lt;/p&gt;&#xA;&lt;p&gt;簡單來說，Queue 的操作只允許在「尾端」加入元素，在「前端」移除元素。&lt;/p&gt;&#xA;&lt;h2 id=&#34;queue-的基本操作&#34;&gt;Queue 的基本操作&lt;/h2&gt;&#xA;&lt;p&gt;Queue 與 Stack 的差異就在於操作的方向：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;enqueue: 將元素放到 Queue 尾端&lt;/li&gt;&#xA;&lt;li&gt;dequeue: 將 Queue 前端的元素移除並回傳&lt;/li&gt;&#xA;&lt;li&gt;peek/front: 查看 Queue 前端的元素，但不移除&lt;/li&gt;&#xA;&lt;li&gt;is_empty: 檢查 Queue 是否為空&lt;/li&gt;&#xA;&lt;li&gt;size: 回傳 Queue 的大小&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;自己建立一個-queue&#34;&gt;自己建立一個 Queue&lt;/h2&gt;&#xA;&lt;p&gt;其實 Queue 跟 Stack 差不多，操作都很簡單，直接使用 Python 來自定義一個 Queue 的資料結構，來進行演示。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Create a Queue class&lt;/p&gt;&#xA;&lt;p&gt;和 Stack 一樣，先建立建構子與迭代器，使用 Python 的 list 模擬：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__iter__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Create an enqueue() method&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 5) 堆疊 (Stack)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_5/</link>
      <pubDate>Wed, 03 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_5/</guid>
      <description>&lt;p&gt;Stack (堆疊) 是一種受限的線性資料結構，遵循先進後出 (Last-In-First-Out; LIFO) 的資料結構。你可想像有一疊盤子，最後放上去的盤子會最先被拿走，所以 Stack 只允許在「頂端」進行操作，簡單來說就是你不能看或是取非最上層的元素。&lt;/p&gt;&#xA;&lt;h2 id=&#34;stack-的基本操作&#34;&gt;Stack 的基本操作&lt;/h2&gt;&#xA;&lt;p&gt;Stack 的操作相較 Linked List 簡單很多，因為他只能對頂端進行操作，常見的操作如下:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;push: 將元素放到 Stack 頂端&lt;/li&gt;&#xA;&lt;li&gt;pop: 將 Stack 頂端的元素移除並回傳 (取走)&lt;/li&gt;&#xA;&lt;li&gt;peek/top: 查看堆疊頂端的元素，但不移除&lt;/li&gt;&#xA;&lt;li&gt;is_empty: 檢查堆疊是否為空&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;自己建立一個-stack&#34;&gt;自己建立一個 Stack&lt;/h2&gt;&#xA;&lt;p&gt;直接使用 Python 來自定義一個 Stack 的資料結構&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Create a Stack class&lt;/p&gt;&#xA;&lt;p&gt;起手式跟昨天一樣，建立建構子與實作 iter，透過 Python 的 list 來模擬。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__iter__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;reversed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Create a push() method&lt;/p&gt;&#xA;&lt;p&gt;Stack 添加元素無法像 Linked List 有那麼多的操作，他一律只能放在最上面，可以想像一下，其實就是把元素加在最後面，再把 list 轉 90 度。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__iter__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;reversed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;    &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Create a pop() method&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 4) 鏈表 (Linked List)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_4/</link>
      <pubDate>Tue, 02 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_4/</guid>
      <description>&lt;p&gt;Linked List (鏈表) 是一種常見的資料結構，用來儲存一系列的元素。與陣列 (Array) 不同，Linked List 的元素稱為節點 (Node) 在記憶體中不必是連續的。每個節點除了儲存資料外，還會儲存一個指向下一個節點的參考 (指標)。&lt;/p&gt;&#xA;&lt;p&gt;但是很不巧的 Python 並沒有像 Java 有支援 Linked List，雖然本系列是以 Python 為主，但是也不會直接使用高階 API 來實作，因為這樣就沒有意義了，所以會使用 Python 來自己建立類別來實現，甚至之後的有些資料結構 Python 都沒有，我也會用 Python 來自定義出類別。&lt;/p&gt;&#xA;&lt;h2 id=&#34;為什麼要用-linked-list&#34;&gt;為什麼要用 Linked List?&lt;/h2&gt;&#xA;&lt;p&gt;相較 Array，Linked List 可以隨時增加或刪除元素，不需要事先宣告大小，而且在在已知位置插入或刪除元素時，只需改變指標，不需搬移其他元素，也就是說如果程式需要頻繁的新增與刪除，Linked List 表現會更為優秀；但是 Linked List 不論是哪種型態的，最多只會儲存前後 Node 的位址，所以當需要查詢的時候，就必須遍歷整個 Linked List，所以在這部分就不及 Array 的效率。&lt;/p&gt;&#xA;&lt;h2 id=&#34;linked-list-的種類&#34;&gt;Linked List 的種類&lt;/h2&gt;&#xA;&lt;p&gt;常見的 Linked List 有以下這幾種型態:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Singly Linked List (單向鏈表):  每個 Node 只指向下一個節點。&lt;/li&gt;&#xA;&lt;li&gt;Doubly Linked List (雙向鏈表): 每個 Node 同時指向前一個和下一個節點。&lt;/li&gt;&#xA;&lt;li&gt;Circular Linked List (循環鏈表): 最後一個 Node 指向第一個節點，形成一個環。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;node-的結構&#34;&gt;Node 的結構&lt;/h3&gt;&#xA;&lt;p&gt;看完 Linked List 的種類，其實會發現這些的差異都在 Node，有的 Node 只指向下一個節點，有 Node 同時指向前一個和下一個節點，接下來我們就用 Python 來演式 Node 的結構:&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 3) 矩陣 (Matrix)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_3/</link>
      <pubDate>Mon, 01 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_3/</guid>
      <description>&lt;p&gt;我不知道大家看到這天會不會驚訝一下，不是應該接續 List 家族這是什麼? Matrix 就是 Array 只是我單獨抽出來說明，如果你沒有在學習或處理資料科學相關的，應該不會使用到 Matrix，但是我認為這是一個蠻常被忽略的部分，也就花一點篇幅來介紹它。&lt;/p&gt;&#xA;&lt;p&gt;Matrix 是由數字、符號或表達式排列成的長方形陣列。從數學的角度來看，對於 m*n 矩陣的形式，可以描述一個電腦中 A(m,n) 二維陣列。&lt;/p&gt;&#xA;&lt;h2 id=&#34;矩陣的表示方式&#34;&gt;矩陣的表示方式&lt;/h2&gt;&#xA;&lt;p&gt;一個 $m$ 行 $n$ 列的矩陣通常寫作:&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;A = \begin{pmatrix}&#xA;a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1n} \&#xA;a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2n} \&#xA;\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \&#xA;a_{m1} &amp;amp; a_{m2} &amp;amp; \cdots &amp;amp; a_{mn}&#xA;\end{pmatrix}&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;其中 $a_{ij}$ 表示第 $i$ 行第 $j$ 列的元素。&lt;/p&gt;&#xA;&lt;h2 id=&#34;常見矩陣種類&#34;&gt;常見矩陣種類&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名稱&lt;/th&gt;&#xA;          &lt;th&gt;定義說明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;行矩陣&lt;/td&gt;&#xA;          &lt;td&gt;只有一行的矩陣 ($1 \times n$)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;列矩陣&lt;/td&gt;&#xA;          &lt;td&gt;只有一列的矩陣 ($m \times 1$)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;方陣&lt;/td&gt;&#xA;          &lt;td&gt;行數與列數相同的矩陣 ($n \times n$)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;零矩陣&lt;/td&gt;&#xA;          &lt;td&gt;所有元素皆為 0 的矩陣&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;單位矩陣&lt;/td&gt;&#xA;          &lt;td&gt;對角線為 1，其餘為 0 的方陣&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;矩陣的基本運算&#34;&gt;矩陣的基本運算&lt;/h2&gt;&#xA;&lt;p&gt;如果你使用資料科學常見的函式庫 (e.g. Numpy)，對於 Matrix 的支援非常的強大，常見的基本運算可能調用一個屬性或方法就能直接處理完成，但是本系列是著重底層知識的理解，所以不會使用到這些高階 API，但是在實務上一定是直接使用這些高階 API。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 2) 陣列 (Array)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_2/</link>
      <pubDate>Sun, 31 Aug 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_2/</guid>
      <description>&lt;p&gt;Array 是一種 Static Data Structure 或稱為 Dense List，它是一種將有序串列的資料結構使用 Contiguous Allocation 來儲存，意味著儲存的元素必須是相同類型，且靜態資料結構的記憶體配置是在編譯時，就必須配置給相關的變數，因此在創建時必須先宣告空間大小。&lt;/p&gt;&#xA;&lt;h2 id=&#34;常見的-array-類型-n-dimensional-array&#34;&gt;常見的 Array 類型 (N-Dimensional Array)&lt;/h2&gt;&#xA;&lt;p&gt;Array 應該是有無限多維，基本上到了 3 維除了圖片外就很少看到，4 維含以上我沒見過，也有可能是我才疏學淺，所以這裡就代表性的介紹 1 ~ 3 維的 Array&lt;/p&gt;&#xA;&lt;h3 id=&#34;one-dimensional-array&#34;&gt;One-Dimensional Array&lt;/h3&gt;&#xA;&lt;p&gt;One-Dimensional Array 是一個在記憶體中連續配置 (contiguously allocated) 的元素序列，所有元素型態一致、大小相同，可透過固定大小的偏移量 element_size 在 O(1) 時間計算任意元素的位址。簡單來說，只要給定起始的位置跟每個空間的大小，就能夠直接算出任意元素的位址，位址公式如下:&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;\text{LOC}(A[i]) = \text{Base}(A) + (i - L) \times w&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;其中:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$\text{LOC}(A[i])$: 表示陣列中第 i 個元素的記憶體位址。&lt;/li&gt;&#xA;&lt;li&gt;$\text{Base}(A)$: 陣列的起始位址。&lt;/li&gt;&#xA;&lt;li&gt;$i$: 要找的索引位置。&lt;/li&gt;&#xA;&lt;li&gt;$L$: 陣列的下標起點 (lower bound)，在大多數語言 (Python, Java, C++)，$L = 0$。&lt;/li&gt;&#xA;&lt;li&gt;$(i - L)$: 表示從起點偏移了幾個元素。&lt;/li&gt;&#xA;&lt;li&gt;$w$: 每個元素的大小 (word size)，以位元組 (bytes) 為單位。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;接下來直接帶入實例計算，假設 $\text{Base}(A) = 1000$、$L = 0$、陣列 ints[5]，型別是 int (4 bytes)，求 A[3] 的位址:&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 1) 介紹與準備</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_1/</link>
      <pubDate>Sat, 30 Aug 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_1/</guid>
      <description>&lt;p&gt;我遇過很多學習程式語言的人，都一直學框架或是 API 怎麼用，都不是很注重底層的知識，我認為一棟樓要蓋多高取決於地基打得多深，因為框架與 API 會變，但時間複雜度、記憶體模型、資料結構設計是不會變的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;為什麼要學資料結構與演算法&#34;&gt;為什麼要學資料結構與演算法?&lt;/h2&gt;&#xA;&lt;p&gt;資料結構與演算法是程式設計的基礎，它們除了能幫助你寫出更有效率的程式，也是很多公司技術面試中必考的內容。其實我個人認為這也是本科與分本科的分水嶺，熟練的掌握這部分，能夠讓你跟那些轉職的工程師拉開距離，脫穎而出。&lt;/p&gt;&#xA;&lt;h2 id=&#34;系列規劃說明&#34;&gt;系列規劃說明&lt;/h2&gt;&#xA;&lt;p&gt;本系列將會依照以下方向進行介紹:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;資料結構 (Data structure)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;陣列 (Array)&lt;/li&gt;&#xA;&lt;li&gt;鏈表 (Linked list)&lt;/li&gt;&#xA;&lt;li&gt;堆疊 (Stack)&lt;/li&gt;&#xA;&lt;li&gt;佇列 (Queue)&lt;/li&gt;&#xA;&lt;li&gt;樹 (Trees)&lt;/li&gt;&#xA;&lt;li&gt;圖 (Graphs)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;演算法 (Algorithms)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;演算法分析 (Algorithm analysis)&lt;/li&gt;&#xA;&lt;li&gt;圖演算法 (Graph algorithms)&lt;/li&gt;&#xA;&lt;li&gt;貪婪演算法 (Greedy algorithms)&lt;/li&gt;&#xA;&lt;li&gt;分治法 (Divide and conquer)&lt;/li&gt;&#xA;&lt;li&gt;動態規劃 (Dynamic programming)&lt;/li&gt;&#xA;&lt;li&gt;網路流 (Network flow)&lt;/li&gt;&#xA;&lt;li&gt;超越多項式運行時間的演算法 (Beyond polynomial running time)&lt;/li&gt;&#xA;&lt;li&gt;線性規劃 (Linear programming)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;本系列的重心會放在演算法的部分，如果有剩餘的篇幅會補充排序或是搜尋的演算法；我會盡量會在每個知識點找個 1 ~ 2 題的 Leetcode 來實作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;技術範圍與預期對象&#34;&gt;技術範圍與預期對象&lt;/h2&gt;&#xA;&lt;p&gt;本系列會以 Python 為範例，但是其實你也不一定需要會 Python，理論上只要有理解，就應該要能夠使用你自己熟悉的語言寫出來，所以本系列只預設讀者至少具備一門程式語言 (Python, Java, C++, JavaScript &amp;hellip;) 的基礎即可。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
