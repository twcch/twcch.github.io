<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>快速掌握資料結構與演算法 on 志謙&#39;s Blog</title>
    <link>http://twcch.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 快速掌握資料結構與演算法 on 志謙&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 Sep 2025 00:00:00 +0800</lastBuildDate>
    <atom:link href="http://twcch.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>(Day 4) 鏈表 (Linked List)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_4/</link>
      <pubDate>Tue, 02 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_4/</guid>
      <description>&lt;p&gt;Linked List (鏈表) 是一種常見的資料結構，用來儲存一系列的元素。與陣列 (Array) 不同，Linked List 的元素稱為節點 (Node) 在記憶體中不必是連續的。每個節點除了儲存資料外，還會儲存一個指向下一個節點的參考 (指標)。&lt;/p&gt;&#xA;&lt;p&gt;但是很不巧的 Python 並沒有像 Java 有支援 Linked List，雖然本系列是以 Python 為主，但是也不會直接使用高階 API 來實作，因為這樣就沒有意義了，所以會使用 Python 來自己建立類別來實現，甚至之後的有些資料結構 Python 都沒有，我也會用 Python 來自定義出類別。&lt;/p&gt;&#xA;&lt;h2 id=&#34;為什麼要用-linked-list&#34;&gt;為什麼要用 Linked List?&lt;/h2&gt;&#xA;&lt;p&gt;相較 Array，Linked List 可以隨時增加或刪除元素，不需要事先宣告大小，而且在在已知位置插入或刪除元素時，只需改變指標，不需搬移其他元素，也就是說如果程式需要頻繁的新增與刪除，Linked List 表現會更為優秀；但是 Linked List 不論是哪種型態的，最多只會儲存前後 Node 的位址，所以當需要查詢的時候，就必須遍歷整個 Linked List，所以在這部分就不及 Array 的效率。&lt;/p&gt;&#xA;&lt;h2 id=&#34;linked-list-的種類&#34;&gt;Linked List 的種類&lt;/h2&gt;&#xA;&lt;p&gt;常見的 Linked List 有以下這幾種型態:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Singly Linked List (單向鏈表):  每個 Node 只指向下一個節點。&lt;/li&gt;&#xA;&lt;li&gt;Doubly Linked List (雙向鏈表): 每個 Node 同時指向前一個和下一個節點。&lt;/li&gt;&#xA;&lt;li&gt;Circular Linked List (循環鏈表): 最後一個 Node 指向第一個節點，形成一個環。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;node-的結構&#34;&gt;Node 的結構&lt;/h3&gt;&#xA;&lt;p&gt;看完 Linked List 的種類，其實會發現這些的差異都在 Node，有的 Node 只指向下一個節點，有 Node 同時指向前一個和下一個節點，接下來我們就用 Python 來演式 Node 的結構:&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 3) 矩陣 (Matrix)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_3/</link>
      <pubDate>Mon, 01 Sep 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_3/</guid>
      <description>&lt;p&gt;我不知道大家看到這天會不會驚訝一下，不是應該接續 List 家族這是什麼? Matrix 就是 Array 只是我單獨抽出來說明，如果你沒有在學習或處理資料科學相關的，應該不會使用到 Matrix，但是我認為這是一個蠻常被忽略的部分，也就花一點篇幅來介紹它。&lt;/p&gt;&#xA;&lt;p&gt;Matrix 是由數字、符號或表達式排列成的長方形陣列。從數學的角度來看，對於 m*n 矩陣的形式，可以描述一個電腦中 A(m,n) 二維陣列。&lt;/p&gt;&#xA;&lt;h2 id=&#34;矩陣的表示方式&#34;&gt;矩陣的表示方式&lt;/h2&gt;&#xA;&lt;p&gt;一個 $m$ 行 $n$ 列的矩陣通常寫作:&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;A = \begin{pmatrix}&#xA;a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1n} \&#xA;a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2n} \&#xA;\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \&#xA;a_{m1} &amp;amp; a_{m2} &amp;amp; \cdots &amp;amp; a_{mn}&#xA;\end{pmatrix}&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;其中 $a_{ij}$ 表示第 $i$ 行第 $j$ 列的元素。&lt;/p&gt;&#xA;&lt;h2 id=&#34;常見矩陣種類&#34;&gt;常見矩陣種類&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名稱&lt;/th&gt;&#xA;          &lt;th&gt;定義說明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;行矩陣&lt;/td&gt;&#xA;          &lt;td&gt;只有一行的矩陣 ($1 \times n$)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;列矩陣&lt;/td&gt;&#xA;          &lt;td&gt;只有一列的矩陣 ($m \times 1$)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;方陣&lt;/td&gt;&#xA;          &lt;td&gt;行數與列數相同的矩陣 ($n \times n$)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;零矩陣&lt;/td&gt;&#xA;          &lt;td&gt;所有元素皆為 0 的矩陣&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;單位矩陣&lt;/td&gt;&#xA;          &lt;td&gt;對角線為 1，其餘為 0 的方陣&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;矩陣的基本運算&#34;&gt;矩陣的基本運算&lt;/h2&gt;&#xA;&lt;p&gt;如果你使用資料科學常見的函式庫 (e.g. Numpy)，對於 Matrix 的支援非常的強大，常見的基本運算可能調用一個屬性或方法就能直接處理完成，但是本系列是著重底層知識的理解，所以不會使用到這些高階 API，但是在實務上一定是直接使用這些高階 API。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 2) 陣列 (Array)</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_2/</link>
      <pubDate>Sun, 31 Aug 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_2/</guid>
      <description>&lt;p&gt;Array 是一種 Static Data Structure 或稱為 Dense List，它是一種將有序串列的資料結構使用 Contiguous Allocation 來儲存，意味著儲存的元素必須是相同類型，且靜態資料結構的記憶體配置是在編譯時，就必須配置給相關的變數，因此在創建時必須先宣告空間大小。&lt;/p&gt;&#xA;&lt;h2 id=&#34;常見的-array-類型-n-dimensional-array&#34;&gt;常見的 Array 類型 (N-Dimensional Array)&lt;/h2&gt;&#xA;&lt;p&gt;Array 應該是有無限多維，基本上到了 3 維除了圖片外就很少看到，4 維含以上我沒見過，也有可能是我才疏學淺，所以這裡就代表性的介紹 1 ~ 3 維的 Array&lt;/p&gt;&#xA;&lt;h3 id=&#34;one-dimensional-array&#34;&gt;One-Dimensional Array&lt;/h3&gt;&#xA;&lt;p&gt;One-Dimensional Array 是一個在記憶體中連續配置 (contiguously allocated) 的元素序列，所有元素型態一致、大小相同，可透過固定大小的偏移量 element_size 在 O(1) 時間計算任意元素的位址。簡單來說，只要給定起始的位置跟每個空間的大小，就能夠直接算出任意元素的位址，位址公式如下:&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;\text{LOC}(A[i]) = \text{Base}(A) + (i - L) \times w&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;其中:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$\text{LOC}(A[i])$: 表示陣列中第 i 個元素的記憶體位址。&lt;/li&gt;&#xA;&lt;li&gt;$\text{Base}(A)$: 陣列的起始位址。&lt;/li&gt;&#xA;&lt;li&gt;$i$: 要找的索引位置。&lt;/li&gt;&#xA;&lt;li&gt;$L$: 陣列的下標起點 (lower bound)，在大多數語言 (Python, Java, C++)，$L = 0$。&lt;/li&gt;&#xA;&lt;li&gt;$(i - L)$: 表示從起點偏移了幾個元素。&lt;/li&gt;&#xA;&lt;li&gt;$w$: 每個元素的大小 (word size)，以位元組 (bytes) 為單位。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;接下來直接帶入實例計算，假設 $\text{Base}(A) = 1000$、$L = 0$、陣列 ints[5]，型別是 int (4 bytes)，求 A[3] 的位址:&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Day 1) 介紹與準備</title>
      <link>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_1/</link>
      <pubDate>Sat, 30 Aug 2025 00:00:00 +0800</pubDate>
      <guid>http://twcch.io/posts/column_articles/ironman_2025/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/ironman_25_2_1/</guid>
      <description>&lt;p&gt;我遇過很多學習程式語言的人，都一直學框架或是 API 怎麼用，都不是很注重底層的知識，我認為一棟樓要蓋多高取決於地基打得多深，因為框架與 API 會變，但時間複雜度、記憶體模型、資料結構設計是不會變的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;為什麼要學資料結構與演算法&#34;&gt;為什麼要學資料結構與演算法?&lt;/h2&gt;&#xA;&lt;p&gt;資料結構與演算法是程式設計的基礎，它們除了能幫助你寫出更有效率的程式，也是很多公司技術面試中必考的內容。其實我個人認為這也是本科與分本科的分水嶺，熟練的掌握這部分，能夠讓你跟那些轉職的工程師拉開距離，脫穎而出。&lt;/p&gt;&#xA;&lt;h2 id=&#34;系列規劃說明&#34;&gt;系列規劃說明&lt;/h2&gt;&#xA;&lt;p&gt;本系列將會依照以下方向進行介紹:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;資料結構 (Data structure)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;陣列 (Array)&lt;/li&gt;&#xA;&lt;li&gt;鏈表 (Linked list)&lt;/li&gt;&#xA;&lt;li&gt;堆疊 (Stack)&lt;/li&gt;&#xA;&lt;li&gt;佇列 (Queue)&lt;/li&gt;&#xA;&lt;li&gt;樹 (Trees)&lt;/li&gt;&#xA;&lt;li&gt;圖 (Graphs)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;演算法 (Algorithms)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;演算法分析 (Algorithm analysis)&lt;/li&gt;&#xA;&lt;li&gt;圖演算法 (Graph algorithms)&lt;/li&gt;&#xA;&lt;li&gt;貪婪演算法 (Greedy algorithms)&lt;/li&gt;&#xA;&lt;li&gt;分治法 (Divide and conquer)&lt;/li&gt;&#xA;&lt;li&gt;動態規劃 (Dynamic programming)&lt;/li&gt;&#xA;&lt;li&gt;網路流 (Network flow)&lt;/li&gt;&#xA;&lt;li&gt;超越多項式運行時間的演算法 (Beyond polynomial running time)&lt;/li&gt;&#xA;&lt;li&gt;線性規劃 (Linear programming)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;本系列的重心會放在演算法的部分，如果有剩餘的篇幅會補充排序或是搜尋的演算法；我會盡量會在每個知識點找個 1 ~ 2 題的 Leetcode 來實作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;技術範圍與預期對象&#34;&gt;技術範圍與預期對象&lt;/h2&gt;&#xA;&lt;p&gt;本系列會以 Python 為範例，但是其實你也不一定需要會 Python，理論上只要有理解，就應該要能夠使用你自己熟悉的語言寫出來，所以本系列只預設讀者至少具備一門程式語言 (Python, Java, C++, JavaScript &amp;hellip;) 的基礎即可。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
